
# 信号分类
- 可靠信号与不可靠信号
- 实时信号与非实时信号
# 信号的处理
- 忽略信号
- 捕获信号，用户自己通过`signal()`来注册信号的处理函数
- 执行系统默认操作，每一种信号都有默认的处理方式，大部分默认处理方式是终止进程
# 常见信号与默认行为
### SIGINT
在终端按Ctrl+c （中断字符）的时候，内核就会发送SIGFINT信号给每一个进程，而大部分进程都把这个SIGINT信号交给系统处理，所以会执行该信号的系统默认操作，也就是退出
### SIGQUIT
在终端按Ctrl+/ （退出字符）的时候，内核将发送 SIGQUIT 信号给前台进程组中的每一 个进程。该信号的系统默认操作是终止进程的运行、并生成可用于调试的核心转储文件。如果陷入无限 循环、或不再响应时，使用 SIGQUIT 信号就很合适。
### SIGBUS
产生该信号（总线错误，bus error）表示发生了某种内存访问错误。该信号的系统默认操作是终止进程。
### SIGABRT
当进程调用 abort()系统调用时（进程异常终止），系统会向该进程发送 SIGABRT 信号。该信号的系统 默认操作是终止进程、并生成核心转储文件。
### SIGKILL
信号为“必杀（sure kill）”信号，用于杀死进程的终极办法，此信号无法被进程阻塞、忽略或者捕 获，故而“一击必杀”，总能终止进程。
Linux 下有一个 kill 命令，kill 命令可用于向进程发送信号，我们会使用"kill -9 xxx"命令 来终止一个进程（xxx 表示进程的 pid），这里的-9 其实指的就是发送编号为 9 的信号，也就是 SIGKILL 信 号。
### SIGUSR1 SIGUSR2
供程序员自定义使用，内核不会产生这些信号，在我们的程序中，可 以使用这些信号来互通通知事件的发生，或是进程彼此同步操作。该信号的系统默认操作是终止进程。
![[Pasted image 20251208231427.png]]

# signal函数
```cpp
# include <signal>
typedef void (*sig_t)(int); 
sig_t signal(int signum, sig_t handler);
```
signum是信号的名字，可以使用宏或者数字编号
handler是自定义的函数，如果写SIG_IGN就是忽略，如果写SIG_DFL就是执行系统默认操作