首先，先讲一下内核编译的流程
我们通过命令`make menuconfig`可以进入图形化的编译配置菜单
这个编译菜单的源文件是Kconfig文件（相当于菜单，让我们点菜）
我们在这里进行配置之后，就会自动生成.config文件（厨师做饭的菜谱）
然后Makefile再跟据.config文件去进行编译
所以，跟据这个流程，我们得先让自己写的驱动出现在Kconfig，也就是菜单上
## 添加Kconfig文件
内核中的驱动文件都有固定的位置，我们编写的helloworld属于字符设备驱动
所以我们进入`drivers/char`新建一个文件夹helloworld
把我们写到.c文件复制进去
`cp ~/drive_learn/1_hello_world/helloworld.c .`
然后在新建一个Kconfig
### Kconfig文件语法
```c
config helloworld
		// bool后面才是菜单里的名字
		bool "helloword support"
		default y
		// 帮助信息
		help
				helloworld
```

	这里的bool这个变量，指的是会有两个选项，加载到内核或者不加载
	可以把类型换成tristate' 就是三种选项，多了一个"编译成模块"


这里写完Kconfig，我们还需要让上一级的，也就是char的 Kconfig包含这个Kconfig
打开上一级的Kconfig
直接加上`source drivers/char/helloworld/Kconfig`

### Makefile编写
这时候，返回内核根目录make menuconfig，就能在
Driver菜单下面的char菜单里面,，看见我们自己的驱动
现在，只能在菜单里看见，但是内核不知道怎么编译，所以我们需要再写一个Makefile
```c
// 这里的CONFIG_之后，是我们Kconnfig里面，第一行的名字
obj-$(CONFIG_helloworld)        +=helloworld.o
```
同样的，我们需要让上一级Makefile包含这个Makefile
打开上一级的，加上
`obj-y        +=helloworld/`

接下来，就应该运行`build.sh kernel`编译内核了
但是里面用的.config文件是用默认的deconfig新生成的，而不是我们刚刚配置的,所以需要对默认的进行覆盖
`cp .config arch/arm64/configs/rockchip_linux_deconfig`
然后就可`build.sh kernel`了