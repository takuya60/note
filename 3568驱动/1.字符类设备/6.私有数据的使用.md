当一个驱动需要同时适配两个设备的时候，这时候的read write等就需要做修改
使用私有数据，相当于面向对象编程
首先需要创建设备的结构体 然后实例化
```c
struct m_dev{
    dev_t dev_id;
    // 这里不需要static
    int major;
    int minor;
    struct cdev m_cdev;
    struct class *m_class;
    struct device *m_device;
    char kbuf[32];
};
struct m_dev dev1;
struct m_dev dev2;
```
在init和exit里面，cdev，class，device都要初始化两次
```c
static int moudle_init(void)
{   
    int ret;

    // 这里用的是dev_id的地址
    // 有两个设备 分配两个设备号
    ret= alloc_chrdev_region(&dev1.dev_id,0,2,"my_char_dev");
    if (ret<0){
        printk("dev_id allo error");
        return 0;
    }
    // 获取分配的设备号
    dev1.major = MAJOR(dev1.major);
    dev1.minor = MINOR(dev1.minor);
    printk("hello dev 1 !\n"); 

    dev1.m_cdev.owner=THIS_MODULE;
    cdev_init(&dev1.m_cdev,&m_ops);
    cdev_add(&dev1.m_cdev,dev1.dev_id,1);

    dev1.m_class=class_create(THIS_MODULE,"test1");
    dev1.m_device=device_create(dev1.m_class,NULL,dev1.dev_id,NULL,"test1");
    // ----------------- 设备2 -----------------
    //这里不用重新申请了，因为一开始就申请了两个，主设备号一样，从设备号直接加1
    dev2.major = MAJOR(dev1.major);
    dev2.minor = MINOR(dev1.minor+1);
    printk("hello dev 2 !\n"); 
    // 注册设备
    dev2.m_cdev.owner=THIS_MODULE;
    cdev_init(&dev2.m_cdev,&m_ops);
    cdev_add(&dev2.m_cdev,dev1.dev_id+1 ,1);
    // 创建设备节点 类的名字不一样
    dev2.m_class=class_create(THIS_MODULE,"test2");
    dev2.m_device=device_create(dev1.m_class,NULL,dev1.dev_id,NULL,"test2");
    return 0;    
}
```
## open 里
 container_of这个函数，能够顺着结构体的一个成员的地址，顺藤摸瓜到整个结构体的地址
 这里的private的data是一个空指针，让他指向打开的这个dev
 这里的具体实现是 通过inode设备节点，找到打开的具体是哪个cdev，再用cdev找到m_dev
 inode设备节点就是应用层的open("dev/dev1",O_RDWR)中，前面的这个
```c
static int m_dev_open (struct inode *inode, struct file *file){
    printk("this is open\n");
    // 这个很重要 尤其是这个cotainer函数  后面这个inod 就是应用层打开的节点
    file->private_data = container_of(inode->i_cdev ,struct m_dev ,m_cdev);
    return 0;
}
```
现在，如果read和write想要对打开的dev进行操作，只需要通过private data这个指针·
而不需dev1.buf 。。。。dev2.。。。。
## read里
此时的private data虽然指向了结构体首地址，但是是一个void  * ，所以需要强制类型转化成struct m_dev * ，重新创建一个 m_dev * 的指针
```c
static ssize_t m_dev_read(struct file *file, char __user *buf, size_t size, loff_t *off){
    printk("this is read\n");
    
    struct m_dev *dev_test =(struct m_dev *)file->private_data;
    if(copy_to_user(buf,dev_test->kbuf,strlen(dev_test->kbuf))<0){
        printk("read error\n");
        return -1;
    }
    return 0;
}
```